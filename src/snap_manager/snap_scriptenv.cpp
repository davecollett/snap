#include <stdio.h>
#include "snapconfig.h"
#include "util/fileutil.h"
#include "wx_includes.hpp"
#include "snap_scriptenv.hpp"
#include "fstream"

using namespace std;

//extern "C"
//{
#include "coordsys/coordsys.h"
//}

// Events generated by the script environment

DEFINE_EVENT_TYPE(wxEVT_SNAP_JOBUPDATED);
DEFINE_EVENT_TYPE(wxEVT_SNAP_CLEARLOG);

// Maximum replacements by replacement funtion, to avoid indefinite loops with replacing 0 length string

const int maxReplace = 10000;

SnapMgrScriptEnv::SnapMgrScriptEnv( wxWindow *frameWindow )
    : frameWindow( frameWindow )
{
    script = new Script( *this );
    config = new wxConfig( _T("SnapMgr"),_T("LINZ"));
    SetupConfiguration();
    GetCoordSysList();
    job = 0;
}

SnapMgrScriptEnv::~SnapMgrScriptEnv()
{
    UnloadJob( false );
    uninstall_crdsys_lists();
    for( size_t i = 0; i < tmpFiles.Count(); i++ )
    {
        ::wxRemoveFile( tmpFiles[i] );
    }
    delete script;
    delete config;
}

void SnapMgrScriptEnv::SetupConfiguration()
{
    // Add the image path to the path variable ...
    // Mainly for the shell command ..

    imageName = wxStandardPaths::Get().GetExecutablePath();
    wxFileName cfg(imageName);
    imagePath = cfg.GetPath();
    wxFileName scriptDir(imageName);
    scriptDir.AppendDir(_T("scripts"));
    scriptPath = scriptDir.GetPath();

    AddSnapDirToPath();

    cfg.SetExt( _T("cfg") );
    if( cfg.FileExists() )
    {
        script->ExecuteScript( cfg.GetFullPath().c_str() );
    }
}

void SnapMgrScriptEnv::GetCoordSysList()
{
    install_default_crdsys_file( (char *) wxStandardPaths::Get().GetExecutablePath().c_str());
    coordsyslist.Empty();
    for( int i = 0; i < coordsys_list_count(); i++ )
    {
        coordsyslist.append(_T("\n"));
        coordsyslist.append(_T(coordsys_list_code(i)));
        coordsyslist.append(_T("\n"));
        coordsyslist.append(_T(coordsys_list_desc(i)));
    }
}

bool SnapMgrScriptEnv::LoadJob( const wxString &jobFile )
{
    if( ! UnloadJob( true ) ) return false;

    {
        wxCommandEvent evt( wxEVT_SNAP_JOBUPDATED );
        evt.SetInt( SNAP_JOBLOADING );
        frameWindow->ProcessEvent(evt);
    }

    wxFileName jobfilename( jobFile );
    jobfilename.MakeAbsolute();
    wxSetWorkingDirectory( jobfilename.GetPath() );

    job = new SnapJob(jobFile);
    if( ! job->IsOk() )
    {
        wxString errormsg;
        for( size_t i = 0; i < job->Errors().Count(); i++ )
        {
            errormsg.Append( job->Errors()[i] );
            errormsg.Append( "\n" );
        }
        ReportError( errormsg );
        return false;
    }

    {
        wxCommandEvent evt( wxEVT_SNAP_JOBUPDATED );
        evt.SetInt( SNAP_JOBUPDATED_NEWJOB );
        frameWindow->ProcessEvent(evt);
    }

    return true;
}

bool SnapMgrScriptEnv::UnloadJob( bool canVeto )
{
    if( ! job ) return true;
    if( canVeto && ! job->IsSaved() )
    {
        wxString message(_T("Job "));
        message.Append( job->GetFilename() );
        message.Append( " has not been saved. Save now?");
        int result = wxMessageBox( message, _T("Save job?"), wxYES_NO | wxCANCEL | wxICON_QUESTION );
        if( result == wxCANCEL ) return false;
        if( result == wxYES ) job->Save();
    }
    delete job;
    job = 0;
    wxCommandEvent evt( wxEVT_SNAP_JOBUPDATED );
    evt.SetInt( SNAP_JOBUPDATED_NEWJOB );
    frameWindow->ProcessEvent(evt);
    return true;
}

bool SnapMgrScriptEnv::UpdateJob()
{
    bool updated = false;
    if( job ) updated = job->Update();
    if( updated )
    {
        wxCommandEvent evt( wxEVT_SNAP_JOBUPDATED );
        evt.SetInt( 0 );
        frameWindow->ProcessEvent(evt);
    }
    return updated;
}

void SnapMgrScriptEnv::AddSnapDirToPath()
{
    wxString pathEnv;
    ::wxGetEnv( _T("PATH"), &pathEnv );
    wxString newPath = imagePath;
	newPath.Append(PATHENV_SEP);
	newPath.Append(imagePath);
	newPath.Append(PATH_SEPARATOR);
	newPath.Append(_T("tools"));
    if( ! pathEnv.IsEmpty() )
    {
        newPath.Append( _T(PATHENV_SEP));   // NOTE: This only works for MSDOS ...
        newPath.Append( pathEnv );
    }
    ::wxSetEnv( _T("PATH"), newPath);
}


void SnapMgrScriptEnv::ReportError( const wxString &error )
{
    wxMessageBox( error,_T("SNAP - error"), wxOK | wxICON_ERROR );
}


// Pass through menu functions ...

int SnapMgrScriptEnv::GetMenuItemCount()
{
    return script ? script->GetMenuItemCount() : 0;
}

bool SnapMgrScriptEnv::GetMenuDefinition( int i, MenuDef &def )
{
    return script ? script->GetMenuDefinition(i, def ) : false;
}

bool SnapMgrScriptEnv::MenuIsValid( int i )
{
    return script ? script->MenuIsValid(i) : false;
}

void SnapMgrScriptEnv::RunMenuActions( int i )
{
    if( script ) script->RunMenuActions( i );
}

// Variables used by the script

#define DEFINE_VARIABLE(vname,vvalue) \
	if( name.IsSameAs(_T(vname),false ) ) { \
		value = Value(vvalue); \
		return true; \
	    }

bool SnapMgrScriptEnv::GetValue( const wxString &name, Value &value )
{
    DEFINE_VARIABLE("$job_valid",(job && job->IsOk()));
    DEFINE_VARIABLE("$job_file",(job ? job->GetFilename() : wxEmptyString ));
    DEFINE_VARIABLE("$job_title",(job ? job->Title() : wxEmptyString));
    DEFINE_VARIABLE("$job_path",(job ? job->GetPath() : wxEmptyString));
    DEFINE_VARIABLE("$snap_path",imagePath);
    DEFINE_VARIABLE("$script_path",scriptPath);
    const char *home_dir = get_app_home_dir();
    DEFINE_VARIABLE("$user_path",home_dir ? home_dir : wxEmptyString);
    DEFINE_VARIABLE("$coordinate_file",(job ? job->CoordinateFilename(): wxEmptyString));
    DEFINE_VARIABLE("$data_files",(job ? job->DataFiles() : wxEmptyString));
    DEFINE_VARIABLE("$load_errors",(job ? job->LoadErrors() : wxEmptyString));
    DEFINE_VARIABLE("$coordsys_list", coordsyslist );
    return false;
}

// Functions used by scripts

#define DEFINE_FUNCTION(func,nprm) \
	if( _stricmp(func,functionName.c_str()) == 0 ) { \
    if( nParams != nprm ) return fsBadParameters;

#define DEFINE_FUNCTION2(func,nprm1,nprm2) \
	if( _stricmp(func,functionName.c_str()) == 0 ) { \
    if( nParams < nprm1 || nParams > nprm2 ) return fsBadParameters;

#define RETURN(v) \
	vresult = Value(v); \
	return fsOk; \
	}

#define CSTRPRM(i) params[i].AsString().c_str()
#define STRPRM(i)  params[i].AsString()
#define BOOLPRM(i) params[i].AsBool()

FunctionStatus SnapMgrScriptEnv::EvaluateFunction( const wxString &functionName, int nParams, Value params[], Value &vresult )
{

    // Message box function

    DEFINE_FUNCTION("Message",2)
    ::wxMessageBox(STRPRM(0),STRPRM(1), wxOK | wxICON_EXCLAMATION );
    RETURN(true)

    // Query function

    DEFINE_FUNCTION("Ask",2)
    int result = ::wxMessageBox(STRPRM(0),STRPRM(1), wxYES_NO | wxICON_QUESTION );
    if( result == wxCANCEL ) return fsTerminateScript;
    RETURN( result == wxYES )

    // Get a file name

    DEFINE_FUNCTION2("GetOpenFileName",2,3)
    bool multiple = nParams == 3 && BOOLPRM(2);
    long style = wxFD_OPEN | wxFD_FILE_MUST_EXIST;
    if( multiple ) style |= wxFD_MULTIPLE;

    wxFileDialog dlg(
        frameWindow,
        STRPRM(0),
        _T("."),
        _T(""),
        STRPRM(1),
        style
    );
    wxString result;
    if( dlg.ShowModal() == wxID_OK )
    {
        if( multiple )
        {
            wxArrayString paths;
            dlg.GetPaths( paths );
            for( size_t i = 0; i < paths.Count(); i++ )
            {
                if( i > 0 ) result.Append("\n");
                result.Append( paths[i] );
            }
        }
        else
        {
            result = dlg.GetPath();
        }
    }
    RETURN( result );

    DEFINE_FUNCTION("GetSaveFileName",2)

    wxFileDialog dlg(
        frameWindow,
        STRPRM(0),
        _T("."),
        _T(""),
        STRPRM(1),
        wxFD_SAVE | wxFD_OVERWRITE_PROMPT
    );
    wxString result;
    if( dlg.ShowModal() == wxID_OK )
    {
        result = dlg.GetPath();
    }
    RETURN( result );

    // Functions for filenames

    DEFINE_FUNCTION("FindProgram",1)
    wxPathList paths;
    paths.AddEnvList(_T("PATH"));
    wxString program = paths.FindAbsoluteValidPath(STRPRM(0));
    RETURN( program );

    // Find job file with specified extension

    DEFINE_FUNCTION("FindJobFile",1)
    wxString fileName;
    if( job )
    {
        wxFileName file(job->GetFilename());
        file.SetExt(STRPRM(0));
        if( file.FileExists() ) { fileName = file.GetFullName(); }
    }
    RETURN( fileName );

    DEFINE_FUNCTION("SetExtension",2)
    wxFileName file(STRPRM(0));
    file.SetExt(STRPRM(1));
    RETURN( file.GetFullPath() )

    DEFINE_FUNCTION("FileExists",1)
    RETURN( ::wxFileExists( STRPRM(0)) )

    DEFINE_FUNCTION2("Filename",2,3)
    wxString result;
    wxFileName file(STRPRM(0));
    wxString part(STRPRM(1));

    if( part.IsSameAs("path",false) ) { result = file.GetPath(); }
    else if( part.IsSameAs("name",false) ) { result = file.GetName(); }
    else if( part.IsSameAs("fullname",false) ) { result = file.GetFullName(); }
    else if( part.IsSameAs("extension",false) ) { result = file.GetExt(); }
    else
    {
        wxString relative;
        if( nParams == 3 ) { relative = STRPRM(2); }
        else { relative = wxGetCwd(); }
        if( part.IsSameAs("absolute",false) )
        {
            file.MakeAbsolute( relative ); result = file.GetFullPath();
        }
        else if( part.IsSameAs("relative",false) )
        {
            file.MakeRelativeTo( relative ); result = file.GetFullPath();
        }
    }
    RETURN( result );

    DEFINE_FUNCTION2("Directory",1,2)
    wxString result;
    wxString files;
    wxString filename;
    wxString filespec = wxEmptyString;
    if( nParams == 2 ) filespec = STRPRM(1);

    wxLogNull noLog;
    wxDir dir(STRPRM(0));
    if( dir.IsOpened() )
    {
        bool found = dir.GetFirst( &files, filespec );
        while( found )
        {
            found = dir.GetNext( &filename );
            if( found ) { files.append("\n"); files.append(filename); }
        }
    }
    RETURN(files)

    // Basic file system functions

    DEFINE_FUNCTION("DeleteFile",1)
    ::wxRemoveFile( STRPRM(0));
    bool result =  ! ::wxFileExists(STRPRM(0));
    if( result && tmpFiles.Index( STRPRM(0) ) != wxNOT_FOUND ) tmpFiles.Remove( STRPRM(0));
    RETURN( result );

    DEFINE_FUNCTION("RenameFile",2)
    bool result = ::wxRenameFile( STRPRM(0), STRPRM(1), true );
    if( result && tmpFiles.Index( STRPRM(0) ) != wxNOT_FOUND ) tmpFiles.Remove( STRPRM(0));
    RETURN(	result  );

    DEFINE_FUNCTION("CopyFile",2)
    RETURN( ::wxCopyFile( STRPRM(0), STRPRM(1),true ));

    DEFINE_FUNCTION("TempFile",0)
    wxString tmpFile = wxFileName::CreateTempFileName("snap.tmp");
    tmpFiles.Add( tmpFile );
    RETURN( tmpFile )

    DEFINE_FUNCTION("WriteFile",2)
    ofstream of(CSTRPRM(0));
    bool result = false;
    if( of.good() )
    {
        of << params[1].AsString();
        of.close();
        result = true;
    }
    RETURN( result )

    DEFINE_FUNCTION2("ReadFile",1,3)
    wxLogNull noLog;
    wxTextFile text(STRPRM(0));
    wxRegEx re;
    long maxLines = 0;
    bool haveRegex = nParams > 1 && re.Compile(STRPRM(1),wxRE_ADVANCED);
    if( nParams > 2 )  STRPRM(2).ToLong(&maxLines);
    wxString result;
    if( text.Open() )
    {
        long nLines = 0;
        for ( wxString str = text.GetFirstLine(); !text.Eof(); str = text.GetNextLine() )
        {
            if( haveRegex && ! re.Matches(str)) continue;
            result.Append( str );
            result.Append( "\n" );
            nLines++;
            if( maxLines && nLines >= maxLines ) break;
        }
    }
    RETURN( result )

    DEFINE_FUNCTION("AppendFile",2)
    ofstream of(CSTRPRM(0), ios::app);
    bool result = false;
    if( of.good() )
    {
        of << params[1].AsString();
        of.close();
        result = true;
    }
    RETURN( result )

    //

    DEFINE_FUNCTION("RunScript",1)
    wxFileName scriptFile(STRPRM(0));

    if( ! scriptFile.IsAbsolute() )
    {
        scriptFile.MakeAbsolute(scriptPath);
    }

    bool result = false;
    if( scriptFile.FileExists() )
    {
        result = script->ExecuteScript( (const char *) scriptFile.GetFullPath().c_str() );
    }
    RETURN( result )



    // Functions to run programs

    DEFINE_FUNCTION2("Run",1,20)
    wxLogNull noLog;
    char **argv = new char *[nParams+1];
    for( int i = 0; i < nParams; i++ ) { argv[i] = const_cast<char *>(CSTRPRM(i)); }
    argv[nParams] = 0;
    frameWindow->SetCursor( *wxHOURGLASS_CURSOR );
    long result = ::wxExecute( argv, wxEXEC_SYNC );
    frameWindow->Raise();
    frameWindow->SetCursor( wxNullCursor );
    delete [] argv;
    wxString resultStr;
    if( result != -1 ) { resultStr << result; }
    RETURN( resultStr );

    DEFINE_FUNCTION2("LogRun",1,20)
    wxLogNull noLog;
    wxString command;
    for( int i = 0; i < nParams; i++ ) { if( i > 0 ) command.Append(" "); command.Append( STRPRM(i)); }
    wxArrayString output;
    wxArrayString errors;
    frameWindow->SetCursor( *wxHOURGLASS_CURSOR );
    long result = ::wxExecute( command, output, errors );
    frameWindow->Raise();
    frameWindow->SetCursor( wxNullCursor );
    wxString outputString;
    if( result != -1 )
    {
        size_t i;
        for( i = 0; i < output.Count(); i++ )
        {
            outputString.Append( output[i] );
            outputString.Append(_T("\n"));
        }
        for( i = 0; i < errors.Count(); i++ )
        {
            outputString.Append( errors[i] );
            outputString.Append(_T("\n"));
        }
        if( outputString.IsEmpty() ) { outputString = wxString("true"); }
    }
    RETURN( outputString );

    DEFINE_FUNCTION2("Start",1,20)
    wxLogNull noLog;
    char **argv = new char *[nParams+1];
    for( int i = 0; i < nParams; i++ ) { argv[i] = const_cast<char *>(CSTRPRM(i)); }
    argv[nParams] = 0;
    long result = ::wxExecute( argv, wxEXEC_ASYNC );
    delete [] argv;
    RETURN( result != 0 );

    // Configuration settings

    DEFINE_FUNCTION("GetConfig",1)
    config->SetPath("/Settings");
    wxString value;
    config->Read( STRPRM(0), &value );
    RETURN( value );


    DEFINE_FUNCTION("SetConfig",2)
    config->SetPath("/Settings");
    bool result = config->Write(STRPRM(0),STRPRM(1));
    RETURN( result );

    // Regular expression match

    DEFINE_FUNCTION2("Match",2,3)
    wxString result;
    wxRegEx re;
    if( re.Compile(STRPRM(1),wxRE_ADVANCED) && re.Matches(STRPRM(0)) )
    {
        size_t start;
        size_t len;
        int nGroup = 0;
        long nm = 0;
        if( nParams == 3 && STRPRM(2).ToLong(&nm) ) nGroup = nm;
        re.GetMatch( &start, &len, nGroup );
        result = STRPRM(0).Mid(start,len);

        //re.GetMatch( result, 0 );
    }
    RETURN( result )

    DEFINE_FUNCTION2("Replace",3,4)
    wxString result( STRPRM(0) );
    wxRegEx re;
    if( re.Compile(STRPRM(1),wxRE_ADVANCED))
    {
        int nReplace = 0;
        long nr;
        if( nParams == 4  && STRPRM(3).ToLong(&nr) ) { nReplace = nr; }
        if( nReplace <= 0 ) nReplace = maxReplace;
        re.Replace( &result, STRPRM(2), nReplace );
    }
    RETURN( result )

    // Date formatting

    DEFINE_FUNCTION2("GetDate",0,1)
    wxString result;
    wxString format;
    if( nParams > 0 )
    {
        format = STRPRM(0);
    }
    else
    {
        format = _T("%#d %b %Y %H:%M");
    }
    result = wxDateTime::Now().Format( format );
    RETURN( result )

    // Environment variable

    DEFINE_FUNCTION("GetEnv",1)
    wxString result;
    wxGetEnv( STRPRM(0), &result );
    RETURN( result )

    // Loading and unloading job is passed back to the frame window,
    // to ensure the user interface is updated...

    DEFINE_FUNCTION("UnloadJob",0)
    bool success = UnloadJob( true );
    RETURN( success )

    DEFINE_FUNCTION("UpdateJob",0)
    bool success = UpdateJob();
    RETURN(success)

    DEFINE_FUNCTION("LoadJob",1)
    bool success = LoadJob(STRPRM(0));
    RETURN( success )

    DEFINE_FUNCTION("Log",1)
    wxLogMessage( "%s", CSTRPRM(0) );
    RETURN( true )

    DEFINE_FUNCTION("ClearLog",0)
    wxCommandEvent evt( wxEVT_SNAP_CLEARLOG );
    frameWindow->ProcessEvent(evt);
    RETURN( true )

    return fsBadFunction;
}

