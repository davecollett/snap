#!/usr/local/bin/perl
#===============================================================================
#
# PROGRAM:             %M%
#
# VERSION:             %I%
#
# WHAT STRING:         %W%
#
# DESCRIPTION:         Perl module to interpolate from triangluated data in
#                      a binary file generated by maketrig.pl.  Note that this
#                      routine may not always work for triangulations which 
#                      do not cover a simple convex shape.
#
# DEPENDENCIES:        
#
# MODIFICATION HISTORY
# NAME                 DATE        DESCRIPTION
# ===================  ==========  ============================================
# Chris Crook          03/02/2004  Created
#===============================================================================


use strict;
use FileHandle;
use Unpacker;

package TrigFile::SplitIndex;

sub new {
   my ($class,$nval,$split,$splitdir) = @_;
   my $self = {
       nval => $nval,
       split => $split,
       splitdir => $splitdir
       };
   return bless $self, $class;
   }

sub Find {
   my ($self, $x, $y ) = @_;
   my @pt = ($x,$y);
   my $split = $self->{split};
   my $splitdir = $self->{splitdir};
   my @limits = (0,$self->{nval}-1);
   my $splitloc = 0;

   while( $limits[0] < $limits[1] ) {
      my $nmid = int(($limits[1]-$limits[0]+2)/2);
      my $dir = $splitdir->[$splitloc] ? 1 : 0;
      if( $pt[$dir] > $split->[$splitloc] ) {
         $limits[0] += $nmid;
         $splitloc += $nmid;
         }
      else {
         $limits[1] = $limits[0]+$nmid-1;
         $splitloc++;
         }
      }
 
   return $limits[0];
   }

package TrigFile;

use vars qw/$debug/;

$debug = 0;

# Each possible triangle file format has a specified header record.  Valid records
# are listed here.  The %formats hash converts these to a format definition
# string - one of TRIG1L (little endian version 1 triangle format), 
# TRIG1B (big endian version 1 triangle format).

my $sigtrig1l = "SNAP trig binary v1.0 \r\n\x1A";
my $sigtrig1b = "CRS trig binary v1.0  \r\n\x1A";

my $siglen = length($sigtrig1l);

my %formats = (
    $sigtrig1l => 'TRIG1L',
    $sigtrig1b => 'TRIG1B' );

sub new {
   my ($class, $filename) = @_;
   
   my $fh = new FileHandle;

   # Open the  triangle file in binary mode.
   
   $fh->open($filename,'r') || die "Cannot open triangle file $filename\n";
   binmode($fh);

   my $self = {
       filename=>$filename,
       fh=>$fh,
       titles=>["Triangle mesh data from file $filename"],
       crdsyscode=>'NONE',
       offset=>0,
       embedded=>0,
       };

   bless $self, $class;
  
   $self->Setup;

   return $self;
   }

sub newEmbedded {
   my ($class, $fh, $offset) = @_;
   
   # Open the  triangle file in binary mode.
   
   my $self = {
       filename=>'Embedded',
       fh=>$fh,
       titles=>["Triangle mesh data embedded in file "],
       crdsyscode=>'NONE',
       offset=>$offset,
       embedded=>1,
       };

   bless $self, $class;
  
   seek($fh,$offset,0);
   $self->Setup;

   return $self;
   }

# Default set up for a LINZ triangle file

sub Setup {
   my ($self) = @_;

   my $filename = $self->{filename};
   my $fh = $self->{fh};
  
   # Read the triangle file signature and ensure that it is valid
   
   my $testsig;
   read($fh,$testsig,$siglen);
   
   my $fmt = $formats{$testsig};
   
   die "$filename is not a valid triangle file - signature incorrect\n" if ! $fmt;
   
   my $filebigendian = $fmt eq 'TRIG1B';
   my $unpacker = new Unpacker($filebigendian,$fh);
   
   # Read location in the file of the triangle index data
   
   my ($loc)=$unpacker->read_long;
   die "Triangle file not completed\n" if ! $loc;
   
   # Jump to the index and  read the triangle data
   
   seek($fh,$loc+$self->{offset},0);
   
   my ($ymn,$ymx,$xmn,$xmx) = $unpacker->read_double(4);

   my $ntrg = $unpacker->read_long;
   
   my ($ndim,$nblock,$blocksize,$nfullblock,$maxblockpoints,$pointcrds)
        =$unpacker->read_short(6);
   
   # Read the triangle descriptive data
   
   my ($s1,$s2,$s3,$s4) = $unpacker->read_string(4);
   
   # Read the file split index ...

   my $nsplit = $nblock-1;
   my @splits;
   my @splitdir;
   my @blocks;

   if( $nsplit > 0 ) {
      @splits = $unpacker->read_double($nsplit);
      @splitdir = $unpacker->read_char($nsplit);
      }

   # Set up the block definitions ... initially unloaded ...

   @blocks = map { {loc=>$_, data=>undef} } $unpacker->read_long($nblock);

   $self->{ titles } = [$s1,$s2,$s3];
   $self->{ crdsyscode } = $s4;
   $self->{ xmin } = $xmn;
   $self->{ xmax } = $xmx;
   $self->{ ymin } = $ymn;
   $self->{ ymax } = $ymx;
   $self->{ ndim } = $ndim;
   $self->{index} = new TrigFile::SplitIndex( $nblock, \@splits, \@splitdir );
   $self->{blocks} = \@blocks;
   $self->{nblock} = $nblock;
   $self->{pointcrds} = $pointcrds;

   $self->{unpacker} = $unpacker;
   }

sub GetBlock {
   my( $self, $blockno ) = @_;
   return undef if $blockno < 0 || $blockno >= $self->{nblock};
   my $block = $self->{blocks}->[$blockno];
  
   if( ! defined ($block->{data}) ) {
       my $fh = $self->{fh};
       my $unpacker = $self->{unpacker};

       seek($fh,$block->{loc}+$self->{offset},0);

       my ($ntrg,$npts) = $unpacker->read_short(2);

       my $nsplit = $ntrg-1;
       my @splits;
       my @splitdir;
       if( $nsplit > 0 ) {
          @splits = $unpacker->read_double($nsplit);
          @splitdir = $unpacker->read_char($nsplit);
          }
       my $index = new TrigFile::SplitIndex($ntrg,\@splits,\@splitdir);

       my @trg;
   
       for my $t (0..$ntrg-1) {
          my @v = $unpacker->read_short(3);
          my @adjacent = $unpacker->read_short(6);
          $trg[$t]->{vertices} = \@v;
          $trg[$t]->{adjacent} = \@adjacent;
          }

       for my $t (0..$ntrg-1) {
          my @c = $unpacker->read_double(2);
          $trg[$t]->{centre} = \@c;
          for my $e (0..2) {
             my @d = $unpacker->read_double(3);
             $trg[$t]->{edgedef}->[$e] = \@d;
             }
          }

       # Load points

       my $ndim = $self->{ndim};
       my @pts;
       my @ptcrds;
 
       for my $i (0..$npts-1) {
          my @v = $unpacker->read_double($ndim);
          $pts[$i] = \@v;
          }
 
       if( $self->{pointcrds} ) {
          for my $i (0..$npts-1) {
             my @v = $unpacker->read_double(2);
             $ptcrds[$i] = \@v;
             }
          }
 
       my $data = {
          ntrg => $ntrg,
          ndim => $ndim,
          index => $index,
          trg => \@trg,
          pts => \@pts,
          ptcrds => \@ptcrds
          };
 
       $block->{data} = $data;
       }

   return $block->{data}
   }


sub DESTROY {
   my( $self ) = @_;
   if( ! $self->{embedded} ) {
     my $fh = $self->{fh};
     close($fh);
     }
   }

sub FileName {
   my ($self) = @_;
   return $self->{filename};
   }

sub Title {
   my ($self) = @_;
   return grep /\S/, @{$self->{titles}};
   }

sub CrdSysCode {
   my ($self) = @_;
   return $self->{crdsyscode};
   }

sub Range {
   my ($self) = @_;
   return @{$self}{ 'xmin', 'ymin', 'xmax', 'ymax' };
   }

sub Dimension {
   my ($self) = @_;
   return $self->{ndim};
   }
  
sub DumpTriangle {
   my ($self, $msg, $nblock, $ntrg ) = @_;
   my $block = $self->GetBlock( $nblock );
   my $trg = $block->{trg}->[$ntrg];
   print $msg,": Block $nblock Triangle $ntrg\n";
   if( $self->{pointcrds} ) {
      my $pen = 2;
      for my $i (0..2,0) {
         my $crd = $block->{ptcrds}->[$trg->{vertices}->[$i]];
         print '   ',join(' ',$pen,@$crd),"\n";
         $pen = 0;
         }
      }
    }
   
sub FindTriangle {
   my( $self, $x, $y ) = @_;
   if( $debug ) {
      print "Seeking triangle for point\n    1 $x $y\n";
      }
   if( $x < $self->{xmin} || $x > $self->{xmax} ||
       $y < $self->{ymin} || $y > $self->{ymax} ){ return undef;}

   my $nblock = $self->{index}->Find( $x, $y );
   my $block = $self->GetBlock( $nblock );

   my $ntrg = $block->{index}->Find( $x, $y );
   my $trg = $block->{trg}->[$ntrg];
   
   # Chase through triangles to find the one to use ...

   my %used;
   while( 1 ) {
     if( $debug ) { $self->DumpTriangle("Searched to triangle",$nblock,$ntrg);}
     my $dx = $x - $trg->{centre}->[0];
     my $dy = $y - $trg->{centre}->[1];
     my $edges = $trg->{edgedef};
     my $maxedge = -1;
     my $maxval = 0;
     for my $e (0..2) {
        my $edge = $edges->[$e];
        my $ds = $dx * $edge->[0] + $dy * $edge->[1];
        if( $ds < -($edge->[2]/3) ) {
           $ds = $edge->[2] > 0 ? -$ds/$edge->[2] : 1000000;
           if( $ds > $maxval ) {
              $maxval = $ds;
              $maxedge = $e;
              }
           }
        elsif ( $maxedge < 0 && $ds > 2*$edge->[2]/3 ) {
           $maxedge = $e == 2 ? 0 : $e + 1;
           }
        }
     last if $maxedge < 0;

     my $nextblock = $trg->{adjacent}->[$maxedge*2];
     return undef if $nextblock < 0 || $nextblock >= $self->{nblock};
     my $nexttrg = $trg->{adjacent}->[$maxedge*2+1];
     last if exists( $used{"$nextblock $nexttrg"} );
     $used{"$nblock $ntrg"} = 1;
     if( $nextblock != $nblock ) {
        $nblock = $nextblock;
        $block = $self->GetBlock( $nblock );
        }
     $ntrg = $nexttrg;
     $trg = $block->{trg}->[$ntrg];
     }

   return ($block,$trg);
   }
   

sub Calc {
   my( $self, $x, $y) = @_;
   my ($block,$trg) = $self->FindTriangle( $x, $y );

   die "Point is not in triangulation\n" if ! $trg;

   my @values;
   $x -= $trg->{centre}->[0];
   $y -= $trg->{centre}->[1];
   my $ndim = $self->{ndim};
   print "Interpolating on triangle\n" if $debug;
   foreach my $e (0..2) {
     my $edge = $trg->{edgedef}->[$e];
     my $wgt = $x*$edge->[0] + $y*$edge->[1];
     $wgt /= $edge->[2] if $edge->[2] > 0.0;
     $wgt += 1.0/3.0;
     my $pt = $block->{pts}->[$trg->{vertices}->[$e]];
     for my $d (0..$ndim-1) {
       $values[$d] += $pt->[$d] * $wgt;
       }
     if( $debug ) {
       print "  ",join(' ',"edge",$e,$trg->{vertices}->[$e],$wgt,@$pt),"\n";
       }
     }
   

   return @values;
   }

1;

